name: CI

on:
  push:
    branches:
      - main
  pull_request:

jobs:
  build-and-publish:
    runs-on: ubuntu-latest
    env:
      build_name: nba-app-ci
      build_number: ${{ github.run_number }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"
      - name: Set up JFrog CLI
        uses: EyalDelarea/setup-jfrog-cli@swampUpAppTrust
        with:
          version: latest
          oidc-provider-name: github-omriz-poc
          oidc-audience: ${{ secrets.JF_URL }}
          disable-job-summary: true
          disable-auto-build-publish: true
          disable-auto-evidence-collection: false
        env:
          JF_URL: ${{ secrets.JF_URL }}
          # Basic authentication credentials
          JF_USER: ${{ secrets.JF_USER }}
          JF_PASSWORD: ${{ secrets.JF_PASSWORD }}
          JF_ACCESS_TOKEN: ${{ secrets.JF_ACCESS_TOKEN }}
          JF_GIT_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      - name: Configure NPM
        run: |
          jf npm-config --repo-deploy poc-npm --repo-resolve poc-npm
      - name: Install dependencies with JFrog CLI
        run: |
          jf npm install --build-name=$build_name --build-number=$build_number  --project poc
      - name: Publish npm package to JFrog Artifactory
        run: |
          jf npm publish --build-name=$build_name --build-number=$build_number  --project poc
      - name: Collect build environment info
        run: |
          jf rt build-collect-env "$build_name" "$build_number" --project poc
      - name: Publish build info to JFrog Artifactory
        run: |
          jf rt build-publish "$build_name" "$build_number"  --project poc
      - name: Generate SonarQube coverage evidence JSON
        env:
          EVIDENCE_PRIVATE_KEY: ${{ secrets.EVIDENCE_PRIVATE_KEY }}
          EVIDENCE_KEY_ALIAS: ${{ secrets.EVIDENCE_KEY_ALIAS }}
        run: |
          sudo apt-get update && sudo apt-get install -y jq
          PACKAGE_VERSION=$(jq -r '.version' package.json)
          PACKAGE_NAME=$(jq -r '.name' package.json)

          mkdir -p .jfrog/evidence
          COVERAGE_PERCENT=87.5
          NOW_TS=$(date -u +"%Y-%m-%dT%H:%M:%SZ")
          cat > .jfrog/evidence/sonarqube-coverage.json <<EOF
          {
            "framework": "jest",
            "status": "PASSED",
            "coveragePercent": ${COVERAGE_PERCENT:-0},
            "generatedAt": "${NOW_TS}",
            "reports": ["coverage/lcov.info", "coverage/index.html"]
          }
          EOF

          cat > .jfrog/evidence/sonarqube-coverage.md <<EOF
          # SonarQube Coverage Evidence

          - **Framework:** jest
          - **Status:** PASSED
          - **Coverage:** ${COVERAGE_PERCENT:-0}%
          - **Reports:** [coverage/lcov.info](coverage/lcov.info), [coverage/index.html](coverage/index.html)
          - **Generated:** ${NOW_TS}
          EOF

          jf evd create-evidence \
            --predicate .jfrog/evidence/sonarqube-coverage.json \
            --markdown .jfrog/evidence/sonarqube-coverage.md \
            --predicate-type "https://jestjs.io/evidence/results/v1" \
            --package-repo-name "$DOCKER_REPO" \
            --package-version "$IMAGE_TAG" \
            --project poc \
            --package-name "$PACKAGE_NAME" \
            --package-version "$PACKAGE_VERSION" \
            --package-repo-name poc-npm \
            --provider-id github-actions \
            --key "${EVIDENCE_PRIVATE_KEY:-}" \
            --key-alias "${EVIDENCE_KEY_ALIAS:-}" 
  create-app-version:
    needs: build-and-publish
    runs-on: ubuntu-latest
    env:
      BUILD_NAME: nba-app-ci
      BUILD_NUMBER: ${{ github.run_number }}
      JF_URL: ${{ secrets.JF_URL }}
      JF_USER: ${{ secrets.JF_USER }}
      JF_PASSWORD: ${{ secrets.JF_PASSWORD }}
      JF_ACCESS_TOKEN: ${{ secrets.JF_ACCESS_TOKEN }}
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      - name: Set up JFrog CLI
        uses: EyalDelarea/setup-jfrog-cli@swampUpAppTrust
        with:
          version: 'latest'
        env:
          JF_URL: ${{ secrets.JF_URL }}
          # Basic authentication credentials
          JF_USER: ${{ secrets.JF_USER }}
          JF_PASSWORD: ${{ secrets.JF_PASSWORD }}
          JF_ACCESS_TOKEN: ${{ secrets.JF_ACCESS_TOKEN }}
          JF_GIT_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      - name: "[Setup] AppTrust variables"
        run: |
          sudo apt-get update && sudo apt-get install -y jq
          APP_VERSION=$(jq -r '.version' package.json)
          APPLICATION_KEY="nba-app"
          echo "APP_VERSION=$APP_VERSION" >> $GITHUB_ENV
          echo "APPLICATION_KEY=$APPLICATION_KEY" >> $GITHUB_ENV
          echo "‚úÖ AppTrust variables set:"
          echo "   üì¶ Application: $APPLICATION_KEY"
          echo "   üè∑Ô∏è Version: $APP_VERSION"
      - name: "[Create] Create AppTrust Application Version"
        run: | 
          envsubst < .jfrog/payloads-templates/app-version-payload-template.json > .jfrog/payloads-templates/app-version-payload-template.json.tmp
          cat .jfrog/payloads-templates/app-version-payload-template.json.tmp
          RESP_BODY="response_body.json"
          HTTP_STATUS=$(curl -sS -L -o "$RESP_BODY" -w "%{http_code}" -X POST \
            "$JF_URL/apptrust/api/v1/applications/$APPLICATION_KEY/versions?async=false" \
            -H "Authorization: Bearer $JF_ACCESS_TOKEN" \
            -H "Accept: application/json" \
            -H "Content-Type: application/json" \
            -H "X-JFrog-Project: poc" \
            -d @.jfrog/payloads-templates/app-version-payload-template.json.tmp)
          echo "üî¢ HTTP Status: $HTTP_STATUS"
          echo "üì® Response Body:"; cat "$RESP_BODY" || true; echo
          rm -f "$RESP_BODY"
          if [[ "$HTTP_STATUS" -lt 200 || "$HTTP_STATUS" -ge 300 ]]; then
            echo "‚ùå Failed to create application version" >&2
            exit 1
          fi
          # Robust validation: fetch content and require status == COMPLETED
          CONTENT_FILE=$(mktemp)
          CONTENT_STATUS=$(curl -sS -L -o "$CONTENT_FILE" -w "%{http_code}" \
            "$JF_URL/apptrust/api/v1/applications/$APPLICATION_KEY/versions/$APP_VERSION/content" \
            -H "Authorization: Bearer $JF_ACCESS_TOKEN" \
            -H "Accept: application/json")
          if [[ "$CONTENT_STATUS" != "200" ]]; then
            echo "‚ùå Version content endpoint returned HTTP $CONTENT_STATUS for $APPLICATION_KEY@$APP_VERSION" >&2
            echo "üì® Response Body:"; cat "$CONTENT_FILE" || true; echo
            rm -f "$CONTENT_FILE"
            exit 1
          fi
          VERSION_STATE=$(jq -r '.status // empty' "$CONTENT_FILE" 2>/dev/null || echo "")
          echo "üì® Version Content:"; cat "$CONTENT_FILE" || true; echo
          rm -f "$CONTENT_FILE"
          if [[ "$VERSION_STATE" != "COMPLETED" ]]; then
            echo "‚ùå Application version not in COMPLETED state (status='$VERSION_STATE') for $APPLICATION_KEY@$APP_VERSION" >&2
            exit 1
          fi
          echo "‚úÖ Application version created and validated (COMPLETED): $APPLICATION_KEY@$APP_VERSION"
          echo "üì¶ Packages will be automatically bound from build sources"
      - name: "[Evidence] Prepare UNASSIGNED templates"
        run: |
          set -euo pipefail
          echo "üìÑ Preparing SLSA and Jira templates"
          cat > slsa.template.md <<'EOF'
          # SLSA Provenance Report üõ°Ô∏è

          This document summarizes the SLSA (Supply-chain Levels for Software Artifacts) provenance and build context for this version.

          ---

          ## Evidence Details

          * **Framework**: `SLSA`
          * **SLSA Level**: `v1`
          * **Generated At**: `${NOW_TS}`
          * **Builder**: `GitHub Actions`
          * **Workflow**: `${{ github.workflow }}`
          * **Repository**: `${{ github.repository }}`
          * **Commit**: `${{ github.sha }}`
          EOF
          cat > jira.template.md <<'EOF'
          # üé´ Jira Release Notes

          This evidence lists the Jira issues included in this application version.

          ---

          ## Tickets
          - ${T1} ‚Äî ${T1_TYPE}
          - ${T2} ‚Äî ${T2_TYPE}
          - ${T3} ‚Äî ${T3_TYPE}
          EOF

      - name: "[Evidence] Attach UNASSIGNED (SLSA, Jira)"
        env:
          EVIDENCE_PRIVATE_KEY: ${{ secrets.EVIDENCE_PRIVATE_KEY }}
        run: |
          set -euo pipefail
          if ! command -v envsubst >/dev/null 2>&1; then sudo apt-get update -y && sudo apt-get install -y gettext-base; fi
          NOW_TS=$(date -u +%Y-%m-%dT%H:%M:%SZ)
          export NOW_TS="${NOW_TS}"
          # SLSA predicate and markdown
          cat > slsa.json <<JSON
          {
            "provenance": {
              "framework": "SLSA",
              "level": "v1",
              "generatedAt": "${NOW_TS}",
              "attachStage": "UNASSIGNED",
              "gateForPromotionTo": "DEV"
            }
          }
          JSON
          envsubst < slsa.template.md > slsa.md
          jf evd create-evidence \
            --predicate slsa.json \
            --markdown slsa.md \
            --predicate-type "https://slsa.dev/provenance/v1" \
            --release-bundle "$APPLICATION_KEY" \
            --release-bundle-version "$APP_VERSION" \
            --project "poc" \
            --key "${{ secrets.EVIDENCE_PRIVATE_KEY }}" \
            --key-alias "${{ secrets.EVIDENCE_KEY_ALIAS }}" || echo "‚ö†Ô∏è SLSA evidence attach failed"

          # Jira predicate and markdown
          # Generate a small set of pseudo tickets and types for the release notes
          T1="BV-$(( (${GITHUB_RUN_NUMBER:-0} % 200) + 100 ))"
          T2="BV-$(( ((${GITHUB_RUN_NUMBER:-0} + ${GITHUB_RUN_ATTEMPT:-0}) % 200) + 300 ))"
          T3="BV-$(( ((${GITHUB_RUN_NUMBER:-0} * 3 + ${GITHUB_RUN_ATTEMPT:-0}) % 200) + 500 ))"
          TYPES=(feature bug improvement)
          T1_TYPE="${TYPES[$(( ${GITHUB_RUN_NUMBER:-0} % 3 ))]}"
          T2_TYPE="${TYPES[$(( (${GITHUB_RUN_NUMBER:-0} + 1) % 3 ))]}"
          T3_TYPE="${TYPES[$(( (${GITHUB_RUN_NUMBER:-0} + 2) % 3 ))]}"
          export T1 T2 T3 T1_TYPE T2_TYPE T3_TYPE
          cat > jira.json <<JSON
          {
            "jira": {
              "tickets": [
                {"id": "${T1}", "type": "${T1_TYPE}"},
                {"id": "${T2}", "type": "${T2_TYPE}"},
                {"id": "${T3}", "type": "${T3_TYPE}"}
              ]
            }
          }
          JSON
          envsubst < jira.template.md > jira.md
          jf evd create-evidence \
            --predicate jira.json \
            --markdown jira.md \
            --predicate-type "https://atlassian.com/evidence/jira/release/v1" \
            --release-bundle "$APPLICATION_KEY" \
            --release-bundle-version "$APP_VERSION" \
            --project "poc" \
            --key "${{ secrets.EVIDENCE_PRIVATE_KEY }}"  \
            --key-alias "${{ secrets.EVIDENCE_KEY_ALIAS }}" || echo "‚ö†Ô∏è Jira evidence attach failed"

